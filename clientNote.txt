Adding a consent screen to improve the user experience during authorization.
As we want to develop a library, should we consider UI or front-end ? or providing api is enough ? or it should not be our concern and oauth client that will have used our library should implement it ? 
In the context of developing RustifyAuth as an OAuth 2.0 authorization server library, the responsibility for implementing a consent screen should generally fall on the OAuth client (the application using your library), rather than on your library itself. Hereâ€™s why:

1. Library's Focus: Providing API and Core Functionality
API-First Approach: Since you are developing a library, your primary focus should be on providing robust APIs that handle the core OAuth 2.0 functionality (like authorization, token generation, PKCE support, scope validation, etc.).
The consent screen is a UI/UX concern, not something that is typically provided by an authorization server library.
Your job is to ensure that the OAuth 2.0 flows (e.g., authorization code flow, client credentials) work properly, with the necessary endpoints and validations. The actual consent screen is part of the user-facing application, which will interact with your library.
2. OAuth Client Responsibility
Customizability: Each OAuth client (the application using your library) might have its own custom user experience requirements and branding for the consent screen. They may want full control over how permissions and scopes are presented to the user.
Separation of Concerns: Your library should expose the necessary API for clients to integrate with, and they can then handle the front-end components, including user consent screens.
Scope Consent: The consent screen is often about informing the user which scopes the application is requesting and allowing the user to approve or deny access. The OAuth client should collect user consent and then forward the appropriate scopes to your authorization server API.
3. Providing API Support for Consent Management
While UI implementation should be the responsibility of the OAuth client, you can provide API support for managing the consent state:
Allow the client application to specify which scopes it needs.
The API should track whether the user has granted consent for specific scopes and return an appropriate authorization code or token based on the consent state.
Example:
Authorization API: The client sends the request for scopes.
Consent Tracking: The library could maintain state internally to track user consent (or provide hooks for the client to store that state).
User Redirect: The client can implement the consent screen and then call your API to proceed with authorization after consent is granted.
4. Why Not Focus on Front-End?
Library vs. Framework: As a library, your scope is narrower than a framework that provides both backend and frontend functionality. A library like RustifyAuth should provide the building blocks for an authorization server but not the user-facing components like the consent UI.
Framework Integration: Developers using your library might want to integrate it into web frameworks like Actix, Rocket, or Warp, which already handle the front-end aspects. They would design and build the consent screen within those frameworks.
5. Examples of Consent Handling
In Google OAuth and other services, the consent screen is part of the UI/UX that Google manages, but the underlying logic for scope consent is part of their OAuth API.
In your case, you should handle:
Scope requests.
Consent state storage (if required).
Issuing tokens based on whether the user has consented to the requested scopes.
